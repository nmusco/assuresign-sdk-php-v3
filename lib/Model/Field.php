<?php
/**
 * Field
 *
 * PHP version 5
 *
 * @category Class
 * @package  Nmusco\AssureSign\v3
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AssureSign DocumentNOW API Documentation
 *
 * AssureSign DocumentNOW electronic signature APIs (envelopes and documents) For DocumentNOW user and account management APIs, go to [Account API](https://account.assuresign.net/api/v3.6/account)
 *
 * The version of the OpenAPI document: 3.6
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Nmusco\AssureSign\v3\Model;

use \ArrayAccess;
use \Nmusco\AssureSign\v3\ObjectSerializer;

/**
 * Field Class Doc Comment
 *
 * @category Class
 * @package  Nmusco\AssureSign\v3
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Field implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'field';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'border_sides' => '\Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentBorderSides',
        'certified' => 'bool',
        'field_type' => 'string',
        'input_type' => 'string',
        'instructions' => 'string',
        'name' => 'string',
        'page_index' => 'int',
        'position' => '\Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentPosition',
        'required' => 'bool',
        'hidden' => 'bool',
        'signer' => 'string',
        'size' => '\Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentSize',
        'source_group' => 'string',
        'tag' => 'string',
        'fixed_text' => 'string',
        'timing' => 'string',
        'options' => '\Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentOptions[]',
        'multiple_choice_default_values' => 'string[]',
        'pen_color' => 'string',
        'signature_type' => 'string',
        'signature_style' => 'string',
        'font_decoration' => '\Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentFontDecoration',
        'font_name' => 'string',
        'font_size' => 'int',
        'horizontal_alignment' => 'string',
        'signer_input_type' => 'string',
        'vertical_alignment' => 'string',
        'word_wrap' => 'bool',
        'formatter_type' => 'string',
        'formatter_code' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'border_sides' => null,
        'certified' => null,
        'field_type' => null,
        'input_type' => null,
        'instructions' => null,
        'name' => null,
        'page_index' => 'int32',
        'position' => null,
        'required' => null,
        'hidden' => null,
        'signer' => null,
        'size' => null,
        'source_group' => null,
        'tag' => null,
        'fixed_text' => null,
        'timing' => null,
        'options' => null,
        'multiple_choice_default_values' => null,
        'pen_color' => null,
        'signature_type' => null,
        'signature_style' => null,
        'font_decoration' => null,
        'font_name' => null,
        'font_size' => null,
        'horizontal_alignment' => null,
        'signer_input_type' => null,
        'vertical_alignment' => null,
        'word_wrap' => null,
        'formatter_type' => null,
        'formatter_code' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'border_sides' => 'borderSides',
        'certified' => 'certified',
        'field_type' => 'fieldType',
        'input_type' => 'inputType',
        'instructions' => 'instructions',
        'name' => 'name',
        'page_index' => 'pageIndex',
        'position' => 'position',
        'required' => 'required',
        'hidden' => 'hidden',
        'signer' => 'signer',
        'size' => 'size',
        'source_group' => 'sourceGroup',
        'tag' => 'tag',
        'fixed_text' => 'fixedText',
        'timing' => 'timing',
        'options' => 'options',
        'multiple_choice_default_values' => 'multipleChoiceDefaultValues',
        'pen_color' => 'penColor',
        'signature_type' => 'signatureType',
        'signature_style' => 'signatureStyle',
        'font_decoration' => 'fontDecoration',
        'font_name' => 'fontName',
        'font_size' => 'fontSize',
        'horizontal_alignment' => 'horizontalAlignment',
        'signer_input_type' => 'signerInputType',
        'vertical_alignment' => 'verticalAlignment',
        'word_wrap' => 'wordWrap',
        'formatter_type' => 'formatterType',
        'formatter_code' => 'formatterCode'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'border_sides' => 'setBorderSides',
        'certified' => 'setCertified',
        'field_type' => 'setFieldType',
        'input_type' => 'setInputType',
        'instructions' => 'setInstructions',
        'name' => 'setName',
        'page_index' => 'setPageIndex',
        'position' => 'setPosition',
        'required' => 'setRequired',
        'hidden' => 'setHidden',
        'signer' => 'setSigner',
        'size' => 'setSize',
        'source_group' => 'setSourceGroup',
        'tag' => 'setTag',
        'fixed_text' => 'setFixedText',
        'timing' => 'setTiming',
        'options' => 'setOptions',
        'multiple_choice_default_values' => 'setMultipleChoiceDefaultValues',
        'pen_color' => 'setPenColor',
        'signature_type' => 'setSignatureType',
        'signature_style' => 'setSignatureStyle',
        'font_decoration' => 'setFontDecoration',
        'font_name' => 'setFontName',
        'font_size' => 'setFontSize',
        'horizontal_alignment' => 'setHorizontalAlignment',
        'signer_input_type' => 'setSignerInputType',
        'vertical_alignment' => 'setVerticalAlignment',
        'word_wrap' => 'setWordWrap',
        'formatter_type' => 'setFormatterType',
        'formatter_code' => 'setFormatterCode'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'border_sides' => 'getBorderSides',
        'certified' => 'getCertified',
        'field_type' => 'getFieldType',
        'input_type' => 'getInputType',
        'instructions' => 'getInstructions',
        'name' => 'getName',
        'page_index' => 'getPageIndex',
        'position' => 'getPosition',
        'required' => 'getRequired',
        'hidden' => 'getHidden',
        'signer' => 'getSigner',
        'size' => 'getSize',
        'source_group' => 'getSourceGroup',
        'tag' => 'getTag',
        'fixed_text' => 'getFixedText',
        'timing' => 'getTiming',
        'options' => 'getOptions',
        'multiple_choice_default_values' => 'getMultipleChoiceDefaultValues',
        'pen_color' => 'getPenColor',
        'signature_type' => 'getSignatureType',
        'signature_style' => 'getSignatureStyle',
        'font_decoration' => 'getFontDecoration',
        'font_name' => 'getFontName',
        'font_size' => 'getFontSize',
        'horizontal_alignment' => 'getHorizontalAlignment',
        'signer_input_type' => 'getSignerInputType',
        'vertical_alignment' => 'getVerticalAlignment',
        'word_wrap' => 'getWordWrap',
        'formatter_type' => 'getFormatterType',
        'formatter_code' => 'getFormatterCode'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const FIELD_TYPE_TYPED = 'Typed';
    const FIELD_TYPE_SIGNATURE = 'Signature';
    const INPUT_TYPE_SIGNER = 'Signer';
    const INPUT_TYPE_FIXED = 'Fixed';
    const INPUT_TYPE_SIGNATORY = 'Signatory';
    const TIMING_START = 'On_Document_Start';
    const TIMING_COMPLETE = 'On_Document_Complete';
    const PEN_COLOR_BLACK = 'Black';
    const PEN_COLOR_BLUE = 'Blue';
    const SIGNATURE_TYPE_SIGNATURE = 'Signature';
    const SIGNATURE_TYPE_INITIALS = 'Initials';
    const SIGNATURE_STYLE_SELECTABLE = 'Selectable';
    const SIGNATURE_STYLE_DRAWN = 'Drawn';
    const SIGNATURE_STYLE_TYPED = 'Typed';
    const SIGNATURE_STYLE_CLASSIC = 'Classic';
    const FONT_NAME_ARIAL = 'Arial';
    const FONT_NAME_BRADLEY_HAND_ITC = 'Bradley_Hand_ITC';
    const FONT_NAME_BRUSH_SCRIPT_BT = 'Brush_Script_BT';
    const FONT_NAME_COURIER_NEW = 'Courier_New';
    const FONT_NAME_TIMES_NEW_ROMAN = 'Times_New_Roman';
    const FONT_NAME_MY_HANDWRITING = 'My_Handwriting';
    const FONT_NAME_OTTO = 'Otto';
    const HORIZONTAL_ALIGNMENT_LEFT = 'Left';
    const HORIZONTAL_ALIGNMENT_CENTER = 'Center';
    const HORIZONTAL_ALIGNMENT_RIGHT = 'Right';
    const SIGNER_INPUT_TYPE_FREE_TEXT = 'Free_Text';
    const SIGNER_INPUT_TYPE_PREFILL = 'Prefill';
    const SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_TEXT = 'Multiple_Choice_Text';
    const SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_GRAPHIC = 'Multiple_Choice_Graphic';
    const SIGNER_INPUT_TYPE_TIMESTAMP = 'Timestamp';
    const SIGNER_INPUT_TYPE_CUSTOM_VALIDATION = 'Custom_Validation';
    const SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_RADIO = 'Multiple_Choice_Radio';
    const SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_CHECKBOX = 'Multiple_Choice_Checkbox';
    const SIGNER_INPUT_TYPE_UNDEFINED = 'Undefined';
    const VERTICAL_ALIGNMENT_TOP = 'Top';
    const VERTICAL_ALIGNMENT_MIDDLE = 'Middle';
    const VERTICAL_ALIGNMENT_BOTTOM = 'Bottom';
    const FORMATTER_TYPE_ALPHANUMERIC = 'ALPHANUMERIC';
    const FORMATTER_TYPE_CREDITCARD = 'CREDITCARD';
    const FORMATTER_TYPE_SSN = 'SSN';
    const FORMATTER_TYPE_CUSTOM = 'CUSTOM';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFieldTypeAllowableValues()
    {
        return [
            self::FIELD_TYPE_TYPED,
            self::FIELD_TYPE_SIGNATURE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInputTypeAllowableValues()
    {
        return [
            self::INPUT_TYPE_SIGNER,
            self::INPUT_TYPE_FIXED,
            self::INPUT_TYPE_SIGNATORY,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTimingAllowableValues()
    {
        return [
            self::TIMING_START,
            self::TIMING_COMPLETE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPenColorAllowableValues()
    {
        return [
            self::PEN_COLOR_BLACK,
            self::PEN_COLOR_BLUE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSignatureTypeAllowableValues()
    {
        return [
            self::SIGNATURE_TYPE_SIGNATURE,
            self::SIGNATURE_TYPE_INITIALS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSignatureStyleAllowableValues()
    {
        return [
            self::SIGNATURE_STYLE_SELECTABLE,
            self::SIGNATURE_STYLE_DRAWN,
            self::SIGNATURE_STYLE_TYPED,
            self::SIGNATURE_STYLE_CLASSIC,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFontNameAllowableValues()
    {
        return [
            self::FONT_NAME_ARIAL,
            self::FONT_NAME_BRADLEY_HAND_ITC,
            self::FONT_NAME_BRUSH_SCRIPT_BT,
            self::FONT_NAME_COURIER_NEW,
            self::FONT_NAME_TIMES_NEW_ROMAN,
            self::FONT_NAME_MY_HANDWRITING,
            self::FONT_NAME_OTTO,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHorizontalAlignmentAllowableValues()
    {
        return [
            self::HORIZONTAL_ALIGNMENT_LEFT,
            self::HORIZONTAL_ALIGNMENT_CENTER,
            self::HORIZONTAL_ALIGNMENT_RIGHT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSignerInputTypeAllowableValues()
    {
        return [
            self::SIGNER_INPUT_TYPE_FREE_TEXT,
            self::SIGNER_INPUT_TYPE_PREFILL,
            self::SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_TEXT,
            self::SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_GRAPHIC,
            self::SIGNER_INPUT_TYPE_TIMESTAMP,
            self::SIGNER_INPUT_TYPE_CUSTOM_VALIDATION,
            self::SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_RADIO,
            self::SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_CHECKBOX,
            self::SIGNER_INPUT_TYPE_UNDEFINED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getVerticalAlignmentAllowableValues()
    {
        return [
            self::VERTICAL_ALIGNMENT_TOP,
            self::VERTICAL_ALIGNMENT_MIDDLE,
            self::VERTICAL_ALIGNMENT_BOTTOM,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFormatterTypeAllowableValues()
    {
        return [
            self::FORMATTER_TYPE_ALPHANUMERIC,
            self::FORMATTER_TYPE_CREDITCARD,
            self::FORMATTER_TYPE_SSN,
            self::FORMATTER_TYPE_CUSTOM,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['border_sides'] = isset($data['border_sides']) ? $data['border_sides'] : null;
        $this->container['certified'] = isset($data['certified']) ? $data['certified'] : null;
        $this->container['field_type'] = isset($data['field_type']) ? $data['field_type'] : null;
        $this->container['input_type'] = isset($data['input_type']) ? $data['input_type'] : null;
        $this->container['instructions'] = isset($data['instructions']) ? $data['instructions'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['page_index'] = isset($data['page_index']) ? $data['page_index'] : null;
        $this->container['position'] = isset($data['position']) ? $data['position'] : null;
        $this->container['required'] = isset($data['required']) ? $data['required'] : null;
        $this->container['hidden'] = isset($data['hidden']) ? $data['hidden'] : null;
        $this->container['signer'] = isset($data['signer']) ? $data['signer'] : null;
        $this->container['size'] = isset($data['size']) ? $data['size'] : null;
        $this->container['source_group'] = isset($data['source_group']) ? $data['source_group'] : null;
        $this->container['tag'] = isset($data['tag']) ? $data['tag'] : null;
        $this->container['fixed_text'] = isset($data['fixed_text']) ? $data['fixed_text'] : null;
        $this->container['timing'] = isset($data['timing']) ? $data['timing'] : null;
        $this->container['options'] = isset($data['options']) ? $data['options'] : null;
        $this->container['multiple_choice_default_values'] = isset($data['multiple_choice_default_values']) ? $data['multiple_choice_default_values'] : null;
        $this->container['pen_color'] = isset($data['pen_color']) ? $data['pen_color'] : null;
        $this->container['signature_type'] = isset($data['signature_type']) ? $data['signature_type'] : null;
        $this->container['signature_style'] = isset($data['signature_style']) ? $data['signature_style'] : null;
        $this->container['font_decoration'] = isset($data['font_decoration']) ? $data['font_decoration'] : null;
        $this->container['font_name'] = isset($data['font_name']) ? $data['font_name'] : null;
        $this->container['font_size'] = isset($data['font_size']) ? $data['font_size'] : null;
        $this->container['horizontal_alignment'] = isset($data['horizontal_alignment']) ? $data['horizontal_alignment'] : null;
        $this->container['signer_input_type'] = isset($data['signer_input_type']) ? $data['signer_input_type'] : null;
        $this->container['vertical_alignment'] = isset($data['vertical_alignment']) ? $data['vertical_alignment'] : null;
        $this->container['word_wrap'] = isset($data['word_wrap']) ? $data['word_wrap'] : null;
        $this->container['formatter_type'] = isset($data['formatter_type']) ? $data['formatter_type'] : null;
        $this->container['formatter_code'] = isset($data['formatter_code']) ? $data['formatter_code'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getFieldTypeAllowableValues();
        if (!is_null($this->container['field_type']) && !in_array($this->container['field_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'field_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getInputTypeAllowableValues();
        if (!is_null($this->container['input_type']) && !in_array($this->container['input_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'input_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTimingAllowableValues();
        if (!is_null($this->container['timing']) && !in_array($this->container['timing'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'timing', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPenColorAllowableValues();
        if (!is_null($this->container['pen_color']) && !in_array($this->container['pen_color'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'pen_color', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSignatureTypeAllowableValues();
        if (!is_null($this->container['signature_type']) && !in_array($this->container['signature_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'signature_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSignatureStyleAllowableValues();
        if (!is_null($this->container['signature_style']) && !in_array($this->container['signature_style'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'signature_style', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getFontNameAllowableValues();
        if (!is_null($this->container['font_name']) && !in_array($this->container['font_name'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'font_name', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getHorizontalAlignmentAllowableValues();
        if (!is_null($this->container['horizontal_alignment']) && !in_array($this->container['horizontal_alignment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'horizontal_alignment', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSignerInputTypeAllowableValues();
        if (!is_null($this->container['signer_input_type']) && !in_array($this->container['signer_input_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'signer_input_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getVerticalAlignmentAllowableValues();
        if (!is_null($this->container['vertical_alignment']) && !in_array($this->container['vertical_alignment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'vertical_alignment', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getFormatterTypeAllowableValues();
        if (!is_null($this->container['formatter_type']) && !in_array($this->container['formatter_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'formatter_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets border_sides
     *
     * @return \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentBorderSides|null
     */
    public function getBorderSides()
    {
        return $this->container['border_sides'];
    }

    /**
     * Sets border_sides
     *
     * @param \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentBorderSides|null $border_sides border_sides
     *
     * @return $this
     */
    public function setBorderSides($border_sides)
    {
        $this->container['border_sides'] = $border_sides;

        return $this;
    }

    /**
     * Gets certified
     *
     * @return bool|null
     */
    public function getCertified()
    {
        return $this->container['certified'];
    }

    /**
     * Sets certified
     *
     * @param bool|null $certified Specifies whether or not printed metadata uniquely identifying the field should be rendered around it to visually distinguish it from other data on the containing page.
     *
     * @return $this
     */
    public function setCertified($certified)
    {
        $this->container['certified'] = $certified;

        return $this;
    }

    /**
     * Gets field_type
     *
     * @return string|null
     */
    public function getFieldType()
    {
        return $this->container['field_type'];
    }

    /**
     * Sets field_type
     *
     * @param string|null $field_type Specifies the type of input required for the field: signature/initials or text.
     *
     * @return $this
     */
    public function setFieldType($field_type)
    {
        $allowedValues = $this->getFieldTypeAllowableValues();
        if (!is_null($field_type) && !in_array($field_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'field_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['field_type'] = $field_type;

        return $this;
    }

    /**
     * Gets input_type
     *
     * @return string|null
     */
    public function getInputType()
    {
        return $this->container['input_type'];
    }

    /**
     * Sets input_type
     *
     * @param string|null $input_type Specifies the source of the input for the field. Possible values include 'Signer' and 'Fixed'.
     *
     * @return $this
     */
    public function setInputType($input_type)
    {
        $allowedValues = $this->getInputTypeAllowableValues();
        if (!is_null($input_type) && !in_array($input_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'input_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['input_type'] = $input_type;

        return $this;
    }

    /**
     * Gets instructions
     *
     * @return string|null
     */
    public function getInstructions()
    {
        return $this->container['instructions'];
    }

    /**
     * Sets instructions
     *
     * @param string|null $instructions Specifies the instructions that will be presented to the signer when they are prompted to provide input for the field.
     *
     * @return $this
     */
    public function setInstructions($instructions)
    {
        $this->container['instructions'] = $instructions;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name Specifies the name of the field.
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets page_index
     *
     * @return int|null
     */
    public function getPageIndex()
    {
        return $this->container['page_index'];
    }

    /**
     * Sets page_index
     *
     * @param int|null $page_index Specifies the 0-based index of the containing page.
     *
     * @return $this
     */
    public function setPageIndex($page_index)
    {
        $this->container['page_index'] = $page_index;

        return $this;
    }

    /**
     * Gets position
     *
     * @return \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentPosition|null
     */
    public function getPosition()
    {
        return $this->container['position'];
    }

    /**
     * Sets position
     *
     * @param \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentPosition|null $position position
     *
     * @return $this
     */
    public function setPosition($position)
    {
        $this->container['position'] = $position;

        return $this;
    }

    /**
     * Gets required
     *
     * @return bool|null
     */
    public function getRequired()
    {
        return $this->container['required'];
    }

    /**
     * Sets required
     *
     * @param bool|null $required Specifies whether or not signer input is required for the field.
     *
     * @return $this
     */
    public function setRequired($required)
    {
        $this->container['required'] = $required;

        return $this;
    }

    /**
     * Gets hidden
     *
     * @return bool|null
     */
    public function getHidden()
    {
        return $this->container['hidden'];
    }

    /**
     * Sets hidden
     *
     * @param bool|null $hidden Specifies whether or not the field is hidden.
     *
     * @return $this
     */
    public function setHidden($hidden)
    {
        $this->container['hidden'] = $hidden;

        return $this;
    }

    /**
     * Gets signer
     *
     * @return string|null
     */
    public function getSigner()
    {
        return $this->container['signer'];
    }

    /**
     * Sets signer
     *
     * @param string|null $signer Specifies the label identifying the intended signer for fields that require signer input (signature or text).
     *
     * @return $this
     */
    public function setSigner($signer)
    {
        $this->container['signer'] = $signer;

        return $this;
    }

    /**
     * Gets size
     *
     * @return \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentSize|null
     */
    public function getSize()
    {
        return $this->container['size'];
    }

    /**
     * Sets size
     *
     * @param \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentSize|null $size size
     *
     * @return $this
     */
    public function setSize($size)
    {
        $this->container['size'] = $size;

        return $this;
    }

    /**
     * Gets source_group
     *
     * @return string|null
     */
    public function getSourceGroup()
    {
        return $this->container['source_group'];
    }

    /**
     * Sets source_group
     *
     * @param string|null $source_group Optionally specifies a common identifier for a group of fields in an envelope that should share a value.
     *
     * @return $this
     */
    public function setSourceGroup($source_group)
    {
        $this->container['source_group'] = $source_group;

        return $this;
    }

    /**
     * Gets tag
     *
     * @return string|null
     */
    public function getTag()
    {
        return $this->container['tag'];
    }

    /**
     * Sets tag
     *
     * @param string|null $tag A generic holder of any information you would like to provide
     *
     * @return $this
     */
    public function setTag($tag)
    {
        $this->container['tag'] = $tag;

        return $this;
    }

    /**
     * Gets fixed_text
     *
     * @return string|null
     */
    public function getFixedText()
    {
        return $this->container['fixed_text'];
    }

    /**
     * Sets fixed_text
     *
     * @param string|null $fixed_text Specifies the text contents for the field for fields with a 'FieldType' of 'Typed' and an 'InputType' of 'Fixed'. Note: content may include merge fields.
     *
     * @return $this
     */
    public function setFixedText($fixed_text)
    {
        $this->container['fixed_text'] = $fixed_text;

        return $this;
    }

    /**
     * Gets timing
     *
     * @return string|null
     */
    public function getTiming()
    {
        return $this->container['timing'];
    }

    /**
     * Sets timing
     *
     * @param string|null $timing Specifies the timing for when the contents of the field will be rendered to the containing document for fields with a 'FieldType' of 'Typed' and an 'InputType' of 'Fixed'.
     *
     * @return $this
     */
    public function setTiming($timing)
    {
        $allowedValues = $this->getTimingAllowableValues();
        if (!is_null($timing) && !in_array($timing, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'timing', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['timing'] = $timing;

        return $this;
    }

    /**
     * Gets options
     *
     * @return \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentOptions[]|null
     */
    public function getOptions()
    {
        return $this->container['options'];
    }

    /**
     * Sets options
     *
     * @param \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentOptions[]|null $options Provides the list of options to present to the signer for fields with a 'FieldType' of 'Typed' and one of the 'Multiple Choice' signatory input types.
     *
     * @return $this
     */
    public function setOptions($options)
    {
        $this->container['options'] = $options;

        return $this;
    }

    /**
     * Gets multiple_choice_default_values
     *
     * @return string[]|null
     */
    public function getMultipleChoiceDefaultValues()
    {
        return $this->container['multiple_choice_default_values'];
    }

    /**
     * Sets multiple_choice_default_values
     *
     * @param string[]|null $multiple_choice_default_values Specify list of values that will be automatically selected upon signing.
     *
     * @return $this
     */
    public function setMultipleChoiceDefaultValues($multiple_choice_default_values)
    {
        $this->container['multiple_choice_default_values'] = $multiple_choice_default_values;

        return $this;
    }

    /**
     * Gets pen_color
     *
     * @return string|null
     */
    public function getPenColor()
    {
        return $this->container['pen_color'];
    }

    /**
     * Sets pen_color
     *
     * @param string|null $pen_color Specifies the color of 'ink' used to render the signature for fields with a 'FieldType' of 'Signature'.
     *
     * @return $this
     */
    public function setPenColor($pen_color)
    {
        $allowedValues = $this->getPenColorAllowableValues();
        if (!is_null($pen_color) && !in_array($pen_color, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'pen_color', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['pen_color'] = $pen_color;

        return $this;
    }

    /**
     * Gets signature_type
     *
     * @return string|null
     */
    public function getSignatureType()
    {
        return $this->container['signature_type'];
    }

    /**
     * Sets signature_type
     *
     * @param string|null $signature_type Specifies the type of signature (initials or signature) the signer will be prompted to provide for fields with a 'FieldType' of 'Signature'.
     *
     * @return $this
     */
    public function setSignatureType($signature_type)
    {
        $allowedValues = $this->getSignatureTypeAllowableValues();
        if (!is_null($signature_type) && !in_array($signature_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'signature_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['signature_type'] = $signature_type;

        return $this;
    }

    /**
     * Gets signature_style
     *
     * @return string|null
     */
    public function getSignatureStyle()
    {
        return $this->container['signature_style'];
    }

    /**
     * Sets signature_style
     *
     * @param string|null $signature_style Specifies the style of signature the signer will adopt for fields with a 'FieldType' of 'Signature'.
     *
     * @return $this
     */
    public function setSignatureStyle($signature_style)
    {
        $allowedValues = $this->getSignatureStyleAllowableValues();
        if (!is_null($signature_style) && !in_array($signature_style, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'signature_style', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['signature_style'] = $signature_style;

        return $this;
    }

    /**
     * Gets font_decoration
     *
     * @return \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentFontDecoration|null
     */
    public function getFontDecoration()
    {
        return $this->container['font_decoration'];
    }

    /**
     * Sets font_decoration
     *
     * @param \Nmusco\AssureSign\v3\Model\PreparedEnvelopeParsedContentFontDecoration|null $font_decoration font_decoration
     *
     * @return $this
     */
    public function setFontDecoration($font_decoration)
    {
        $this->container['font_decoration'] = $font_decoration;

        return $this;
    }

    /**
     * Gets font_name
     *
     * @return string|null
     */
    public function getFontName()
    {
        return $this->container['font_name'];
    }

    /**
     * Sets font_name
     *
     * @param string|null $font_name Specifies the name of the supported font that should be used to render the contents of the field for fields with a 'FieldType' of 'Typed'.
     *
     * @return $this
     */
    public function setFontName($font_name)
    {
        $allowedValues = $this->getFontNameAllowableValues();
        if (!is_null($font_name) && !in_array($font_name, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'font_name', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['font_name'] = $font_name;

        return $this;
    }

    /**
     * Gets font_size
     *
     * @return int|null
     */
    public function getFontSize()
    {
        return $this->container['font_size'];
    }

    /**
     * Sets font_size
     *
     * @param int|null $font_size Specifies the size of the font that should be used to render the contents of the field for fields with a 'FieldType' of 'Typed'. Possible values include: 6, 8, 10, 12, 14
     *
     * @return $this
     */
    public function setFontSize($font_size)
    {
        $this->container['font_size'] = $font_size;

        return $this;
    }

    /**
     * Gets horizontal_alignment
     *
     * @return string|null
     */
    public function getHorizontalAlignment()
    {
        return $this->container['horizontal_alignment'];
    }

    /**
     * Sets horizontal_alignment
     *
     * @param string|null $horizontal_alignment Specifies the horizontal alignment of the field contents for fields with a 'FieldType' of 'Typed'.
     *
     * @return $this
     */
    public function setHorizontalAlignment($horizontal_alignment)
    {
        $allowedValues = $this->getHorizontalAlignmentAllowableValues();
        if (!is_null($horizontal_alignment) && !in_array($horizontal_alignment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'horizontal_alignment', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['horizontal_alignment'] = $horizontal_alignment;

        return $this;
    }

    /**
     * Gets signer_input_type
     *
     * @return string|null
     */
    public function getSignerInputType()
    {
        return $this->container['signer_input_type'];
    }

    /**
     * Sets signer_input_type
     *
     * @param string|null $signer_input_type Specifies the type of input required from the signer for fields with a 'FieldType' of 'Typed'.
     *
     * @return $this
     */
    public function setSignerInputType($signer_input_type)
    {
        $allowedValues = $this->getSignerInputTypeAllowableValues();
        if (!is_null($signer_input_type) && !in_array($signer_input_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'signer_input_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['signer_input_type'] = $signer_input_type;

        return $this;
    }

    /**
     * Gets vertical_alignment
     *
     * @return string|null
     */
    public function getVerticalAlignment()
    {
        return $this->container['vertical_alignment'];
    }

    /**
     * Sets vertical_alignment
     *
     * @param string|null $vertical_alignment Specifies the vertical alignment of the field contents for fields with a 'FieldType' of 'Typed'.
     *
     * @return $this
     */
    public function setVerticalAlignment($vertical_alignment)
    {
        $allowedValues = $this->getVerticalAlignmentAllowableValues();
        if (!is_null($vertical_alignment) && !in_array($vertical_alignment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'vertical_alignment', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['vertical_alignment'] = $vertical_alignment;

        return $this;
    }

    /**
     * Gets word_wrap
     *
     * @return bool|null
     */
    public function getWordWrap()
    {
        return $this->container['word_wrap'];
    }

    /**
     * Sets word_wrap
     *
     * @param bool|null $word_wrap Specifies whether or not the contents of the field should be automatically wrapped to a new line for fields with a 'FieldType' of 'Typed'.
     *
     * @return $this
     */
    public function setWordWrap($word_wrap)
    {
        $this->container['word_wrap'] = $word_wrap;

        return $this;
    }

    /**
     * Gets formatter_type
     *
     * @return string|null
     */
    public function getFormatterType()
    {
        return $this->container['formatter_type'];
    }

    /**
     * Sets formatter_type
     *
     * @param string|null $formatter_type Specifies the text mask to apply for fields with a 'FieldType' of 'Typed'.
     *
     * @return $this
     */
    public function setFormatterType($formatter_type)
    {
        $allowedValues = $this->getFormatterTypeAllowableValues();
        if (!is_null($formatter_type) && !in_array($formatter_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'formatter_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['formatter_type'] = $formatter_type;

        return $this;
    }

    /**
     * Gets formatter_code
     *
     * @return string|null
     */
    public function getFormatterCode()
    {
        return $this->container['formatter_code'];
    }

    /**
     * Sets formatter_code
     *
     * @param string|null $formatter_code Specifies the custom text mask to apply for fields with a 'FieldType' of 'Typed' and a 'FormatterType' of 'Fixed'.
     *
     * @return $this
     */
    public function setFormatterCode($formatter_code)
    {
        $this->container['formatter_code'] = $formatter_code;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


