<?php
/**
 * Webhook
 *
 * PHP version 5
 *
 * @category Class
 * @package  Nmusco\AssureSign\v3
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AssureSign DocumentNOW API Documentation
 *
 * AssureSign DocumentNOW electronic signature APIs (envelopes and documents) For DocumentNOW user and account management APIs, go to [Account API](https://account.assuresign.net/api/v3.6/account)
 *
 * The version of the OpenAPI document: 3.6
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Nmusco\AssureSign\v3\Model;

use \ArrayAccess;
use \Nmusco\AssureSign\v3\ObjectSerializer;

/**
 * Webhook Class Doc Comment
 *
 * @category Class
 * @description An explanation about the purpose of this instance.
 * @package  Nmusco\AssureSign\v3
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Webhook implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'webhook';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'web_hook_id' => 'string',
        'username' => 'string',
        'password' => 'string',
        'domain' => 'string',
        'name' => 'string',
        'endpoint' => 'string',
        'headers' => '\Nmusco\AssureSign\v3\Model\WebhookHeader[]',
        'authentication_type' => 'string',
        'http_method' => 'string',
        'request_body' => 'string',
        'content_type' => 'string',
        'validators' => '\Nmusco\AssureSign\v3\Model\WebhookValidator[]',
        'response_values' => '\Nmusco\AssureSign\v3\Model\WebhookResponseValue[]',
        'notify_on_failure' => 'string',
        'technical_contact_email_addresses' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'web_hook_id' => 'uuid',
        'username' => null,
        'password' => null,
        'domain' => null,
        'name' => null,
        'endpoint' => null,
        'headers' => null,
        'authentication_type' => null,
        'http_method' => null,
        'request_body' => null,
        'content_type' => null,
        'validators' => null,
        'response_values' => null,
        'notify_on_failure' => null,
        'technical_contact_email_addresses' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'web_hook_id' => 'webHookID',
        'username' => 'username',
        'password' => 'password',
        'domain' => 'domain',
        'name' => 'name',
        'endpoint' => 'endpoint',
        'headers' => 'headers',
        'authentication_type' => 'authenticationType',
        'http_method' => 'httpMethod',
        'request_body' => 'requestBody',
        'content_type' => 'contentType',
        'validators' => 'validators',
        'response_values' => 'responseValues',
        'notify_on_failure' => 'notifyOnFailure',
        'technical_contact_email_addresses' => 'technicalContactEmailAddresses'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'web_hook_id' => 'setWebHookId',
        'username' => 'setUsername',
        'password' => 'setPassword',
        'domain' => 'setDomain',
        'name' => 'setName',
        'endpoint' => 'setEndpoint',
        'headers' => 'setHeaders',
        'authentication_type' => 'setAuthenticationType',
        'http_method' => 'setHttpMethod',
        'request_body' => 'setRequestBody',
        'content_type' => 'setContentType',
        'validators' => 'setValidators',
        'response_values' => 'setResponseValues',
        'notify_on_failure' => 'setNotifyOnFailure',
        'technical_contact_email_addresses' => 'setTechnicalContactEmailAddresses'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'web_hook_id' => 'getWebHookId',
        'username' => 'getUsername',
        'password' => 'getPassword',
        'domain' => 'getDomain',
        'name' => 'getName',
        'endpoint' => 'getEndpoint',
        'headers' => 'getHeaders',
        'authentication_type' => 'getAuthenticationType',
        'http_method' => 'getHttpMethod',
        'request_body' => 'getRequestBody',
        'content_type' => 'getContentType',
        'validators' => 'getValidators',
        'response_values' => 'getResponseValues',
        'notify_on_failure' => 'getNotifyOnFailure',
        'technical_contact_email_addresses' => 'getTechnicalContactEmailAddresses'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const AUTHENTICATION_TYPE_NONE = 'None';
    const AUTHENTICATION_TYPE_BASIC = 'Basic';
    const AUTHENTICATION_TYPE_BEARER = 'Bearer';
    const HTTP_METHOD_POST = 'Post';
    const HTTP_METHOD_PUT = 'Put';
    const HTTP_METHOD_GET = 'Get';
    const HTTP_METHOD_PATCH = 'Patch';
    const CONTENT_TYPE_APPLICATION_JSON = 'application/json';
    const CONTENT_TYPE_TEXT_XML = 'text/xml';
    const CONTENT_TYPE_TEXT_PLAIN = 'text/plain';
    const NOTIFY_ON_FAILURE_FIRST = 'first';
    const NOTIFY_ON_FAILURE__FINAL = 'final';
    const NOTIFY_ON_FAILURE_ALL = 'all';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthenticationTypeAllowableValues()
    {
        return [
            self::AUTHENTICATION_TYPE_NONE,
            self::AUTHENTICATION_TYPE_BASIC,
            self::AUTHENTICATION_TYPE_BEARER,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHttpMethodAllowableValues()
    {
        return [
            self::HTTP_METHOD_POST,
            self::HTTP_METHOD_PUT,
            self::HTTP_METHOD_GET,
            self::HTTP_METHOD_PATCH,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getContentTypeAllowableValues()
    {
        return [
            self::CONTENT_TYPE_APPLICATION_JSON,
            self::CONTENT_TYPE_TEXT_XML,
            self::CONTENT_TYPE_TEXT_PLAIN,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getNotifyOnFailureAllowableValues()
    {
        return [
            self::NOTIFY_ON_FAILURE_FIRST,
            self::NOTIFY_ON_FAILURE__FINAL,
            self::NOTIFY_ON_FAILURE_ALL,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['web_hook_id'] = isset($data['web_hook_id']) ? $data['web_hook_id'] : null;
        $this->container['username'] = isset($data['username']) ? $data['username'] : null;
        $this->container['password'] = isset($data['password']) ? $data['password'] : null;
        $this->container['domain'] = isset($data['domain']) ? $data['domain'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['endpoint'] = isset($data['endpoint']) ? $data['endpoint'] : null;
        $this->container['headers'] = isset($data['headers']) ? $data['headers'] : null;
        $this->container['authentication_type'] = isset($data['authentication_type']) ? $data['authentication_type'] : 'None';
        $this->container['http_method'] = isset($data['http_method']) ? $data['http_method'] : null;
        $this->container['request_body'] = isset($data['request_body']) ? $data['request_body'] : null;
        $this->container['content_type'] = isset($data['content_type']) ? $data['content_type'] : null;
        $this->container['validators'] = isset($data['validators']) ? $data['validators'] : null;
        $this->container['response_values'] = isset($data['response_values']) ? $data['response_values'] : null;
        $this->container['notify_on_failure'] = isset($data['notify_on_failure']) ? $data['notify_on_failure'] : null;
        $this->container['technical_contact_email_addresses'] = isset($data['technical_contact_email_addresses']) ? $data['technical_contact_email_addresses'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getAuthenticationTypeAllowableValues();
        if (!is_null($this->container['authentication_type']) && !in_array($this->container['authentication_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'authentication_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getHttpMethodAllowableValues();
        if (!is_null($this->container['http_method']) && !in_array($this->container['http_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'http_method', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getContentTypeAllowableValues();
        if (!is_null($this->container['content_type']) && !in_array($this->container['content_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'content_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getNotifyOnFailureAllowableValues();
        if (!is_null($this->container['notify_on_failure']) && !in_array($this->container['notify_on_failure'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'notify_on_failure', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets web_hook_id
     *
     * @return string|null
     */
    public function getWebHookId()
    {
        return $this->container['web_hook_id'];
    }

    /**
     * Sets web_hook_id
     *
     * @param string|null $web_hook_id web_hook_id
     *
     * @return $this
     */
    public function setWebHookId($web_hook_id)
    {
        $this->container['web_hook_id'] = $web_hook_id;

        return $this;
    }

    /**
     * Gets username
     *
     * @return string|null
     */
    public function getUsername()
    {
        return $this->container['username'];
    }

    /**
     * Sets username
     *
     * @param string|null $username username
     *
     * @return $this
     */
    public function setUsername($username)
    {
        $this->container['username'] = $username;

        return $this;
    }

    /**
     * Gets password
     *
     * @return string|null
     */
    public function getPassword()
    {
        return $this->container['password'];
    }

    /**
     * Sets password
     *
     * @param string|null $password password
     *
     * @return $this
     */
    public function setPassword($password)
    {
        $this->container['password'] = $password;

        return $this;
    }

    /**
     * Gets domain
     *
     * @return string|null
     */
    public function getDomain()
    {
        return $this->container['domain'];
    }

    /**
     * Sets domain
     *
     * @param string|null $domain domain
     *
     * @return $this
     */
    public function setDomain($domain)
    {
        $this->container['domain'] = $domain;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name name
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets endpoint
     *
     * @return string|null
     */
    public function getEndpoint()
    {
        return $this->container['endpoint'];
    }

    /**
     * Sets endpoint
     *
     * @param string|null $endpoint endpoint
     *
     * @return $this
     */
    public function setEndpoint($endpoint)
    {
        $this->container['endpoint'] = $endpoint;

        return $this;
    }

    /**
     * Gets headers
     *
     * @return \Nmusco\AssureSign\v3\Model\WebhookHeader[]|null
     */
    public function getHeaders()
    {
        return $this->container['headers'];
    }

    /**
     * Sets headers
     *
     * @param \Nmusco\AssureSign\v3\Model\WebhookHeader[]|null $headers headers
     *
     * @return $this
     */
    public function setHeaders($headers)
    {
        $this->container['headers'] = $headers;

        return $this;
    }

    /**
     * Gets authentication_type
     *
     * @return string|null
     */
    public function getAuthenticationType()
    {
        return $this->container['authentication_type'];
    }

    /**
     * Sets authentication_type
     *
     * @param string|null $authentication_type authentication_type
     *
     * @return $this
     */
    public function setAuthenticationType($authentication_type)
    {
        $allowedValues = $this->getAuthenticationTypeAllowableValues();
        if (!is_null($authentication_type) && !in_array($authentication_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'authentication_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['authentication_type'] = $authentication_type;

        return $this;
    }

    /**
     * Gets http_method
     *
     * @return string|null
     */
    public function getHttpMethod()
    {
        return $this->container['http_method'];
    }

    /**
     * Sets http_method
     *
     * @param string|null $http_method http_method
     *
     * @return $this
     */
    public function setHttpMethod($http_method)
    {
        $allowedValues = $this->getHttpMethodAllowableValues();
        if (!is_null($http_method) && !in_array($http_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'http_method', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['http_method'] = $http_method;

        return $this;
    }

    /**
     * Gets request_body
     *
     * @return string|null
     */
    public function getRequestBody()
    {
        return $this->container['request_body'];
    }

    /**
     * Sets request_body
     *
     * @param string|null $request_body request_body
     *
     * @return $this
     */
    public function setRequestBody($request_body)
    {
        $this->container['request_body'] = $request_body;

        return $this;
    }

    /**
     * Gets content_type
     *
     * @return string|null
     */
    public function getContentType()
    {
        return $this->container['content_type'];
    }

    /**
     * Sets content_type
     *
     * @param string|null $content_type content_type
     *
     * @return $this
     */
    public function setContentType($content_type)
    {
        $allowedValues = $this->getContentTypeAllowableValues();
        if (!is_null($content_type) && !in_array($content_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'content_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['content_type'] = $content_type;

        return $this;
    }

    /**
     * Gets validators
     *
     * @return \Nmusco\AssureSign\v3\Model\WebhookValidator[]|null
     */
    public function getValidators()
    {
        return $this->container['validators'];
    }

    /**
     * Sets validators
     *
     * @param \Nmusco\AssureSign\v3\Model\WebhookValidator[]|null $validators validators
     *
     * @return $this
     */
    public function setValidators($validators)
    {
        $this->container['validators'] = $validators;

        return $this;
    }

    /**
     * Gets response_values
     *
     * @return \Nmusco\AssureSign\v3\Model\WebhookResponseValue[]|null
     */
    public function getResponseValues()
    {
        return $this->container['response_values'];
    }

    /**
     * Sets response_values
     *
     * @param \Nmusco\AssureSign\v3\Model\WebhookResponseValue[]|null $response_values response_values
     *
     * @return $this
     */
    public function setResponseValues($response_values)
    {
        $this->container['response_values'] = $response_values;

        return $this;
    }

    /**
     * Gets notify_on_failure
     *
     * @return string|null
     */
    public function getNotifyOnFailure()
    {
        return $this->container['notify_on_failure'];
    }

    /**
     * Sets notify_on_failure
     *
     * @param string|null $notify_on_failure notify_on_failure
     *
     * @return $this
     */
    public function setNotifyOnFailure($notify_on_failure)
    {
        $allowedValues = $this->getNotifyOnFailureAllowableValues();
        if (!is_null($notify_on_failure) && !in_array($notify_on_failure, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'notify_on_failure', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['notify_on_failure'] = $notify_on_failure;

        return $this;
    }

    /**
     * Gets technical_contact_email_addresses
     *
     * @return string[]|null
     */
    public function getTechnicalContactEmailAddresses()
    {
        return $this->container['technical_contact_email_addresses'];
    }

    /**
     * Sets technical_contact_email_addresses
     *
     * @param string[]|null $technical_contact_email_addresses technical_contact_email_addresses
     *
     * @return $this
     */
    public function setTechnicalContactEmailAddresses($technical_contact_email_addresses)
    {
        $this->container['technical_contact_email_addresses'] = $technical_contact_email_addresses;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


