<?php
/**
 * Field
 *
 * PHP version 5
 *
 * @category Class
 * @package  Nmusco\AssureSign\v3
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AssureSign DocumentNOW API Documentation
 *
 * <h2>AssureSign DocumentNOW electronic signature APIs (envelopes and documents)</h2><h3>For DocumentNOW user and account management APIs, go to [Account API](https://account.assuresign.net/api/v3.6/account)</h3>
 *
 * The version of the OpenAPI document: 3.6
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.2.3
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Nmusco\AssureSign\v3\Model;

use \ArrayAccess;
use \Nmusco\AssureSign\v3\ObjectSerializer;

/**
 * Field Class Doc Comment
 *
 * @category Class
 * @package  Nmusco\AssureSign\v3
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Field implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'field';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'borderSides' => '\Nmusco\AssureSign\v3\Model\FieldBorderSides',
        'certified' => 'bool',
        'fieldType' => 'string',
        'inputType' => 'string',
        'instructions' => 'string',
        'name' => 'string',
        'pageIndex' => 'int',
        'position' => '\Nmusco\AssureSign\v3\Model\Coordinate',
        'required' => 'bool',
        'hidden' => 'bool',
        'signer' => 'string',
        'size' => '\Nmusco\AssureSign\v3\Model\FieldSize',
        'sourceGroup' => 'string',
        'tag' => 'string',
        'fixedText' => 'string',
        'timing' => 'string',
        'options' => '\Nmusco\AssureSign\v3\Model\FieldOption[]',
        'multipleChoiceDefaultValues' => 'string[]',
        'penColor' => 'string',
        'signatureType' => 'string',
        'signatureStyle' => 'string',
        'fontDecoration' => '\Nmusco\AssureSign\v3\Model\FieldFontDecoration',
        'fontName' => 'string',
        'fontSize' => 'int',
        'horizontalAlignment' => 'string',
        'signerInputType' => 'string',
        'verticalAlignment' => 'string',
        'wordWrap' => 'bool',
        'formatterType' => 'string',
        'formatterCode' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'borderSides' => null,
        'certified' => null,
        'fieldType' => null,
        'inputType' => null,
        'instructions' => null,
        'name' => null,
        'pageIndex' => 'int32',
        'position' => null,
        'required' => null,
        'hidden' => null,
        'signer' => null,
        'size' => null,
        'sourceGroup' => null,
        'tag' => null,
        'fixedText' => null,
        'timing' => null,
        'options' => null,
        'multipleChoiceDefaultValues' => null,
        'penColor' => null,
        'signatureType' => null,
        'signatureStyle' => null,
        'fontDecoration' => null,
        'fontName' => null,
        'fontSize' => null,
        'horizontalAlignment' => null,
        'signerInputType' => null,
        'verticalAlignment' => null,
        'wordWrap' => null,
        'formatterType' => null,
        'formatterCode' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'borderSides' => 'borderSides',
        'certified' => 'certified',
        'fieldType' => 'fieldType',
        'inputType' => 'inputType',
        'instructions' => 'instructions',
        'name' => 'name',
        'pageIndex' => 'pageIndex',
        'position' => 'position',
        'required' => 'required',
        'hidden' => 'hidden',
        'signer' => 'signer',
        'size' => 'size',
        'sourceGroup' => 'sourceGroup',
        'tag' => 'tag',
        'fixedText' => 'fixedText',
        'timing' => 'timing',
        'options' => 'options',
        'multipleChoiceDefaultValues' => 'multipleChoiceDefaultValues',
        'penColor' => 'penColor',
        'signatureType' => 'signatureType',
        'signatureStyle' => 'signatureStyle',
        'fontDecoration' => 'fontDecoration',
        'fontName' => 'fontName',
        'fontSize' => 'fontSize',
        'horizontalAlignment' => 'horizontalAlignment',
        'signerInputType' => 'signerInputType',
        'verticalAlignment' => 'verticalAlignment',
        'wordWrap' => 'wordWrap',
        'formatterType' => 'formatterType',
        'formatterCode' => 'formatterCode'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'borderSides' => 'setBorderSides',
        'certified' => 'setCertified',
        'fieldType' => 'setFieldType',
        'inputType' => 'setInputType',
        'instructions' => 'setInstructions',
        'name' => 'setName',
        'pageIndex' => 'setPageIndex',
        'position' => 'setPosition',
        'required' => 'setRequired',
        'hidden' => 'setHidden',
        'signer' => 'setSigner',
        'size' => 'setSize',
        'sourceGroup' => 'setSourceGroup',
        'tag' => 'setTag',
        'fixedText' => 'setFixedText',
        'timing' => 'setTiming',
        'options' => 'setOptions',
        'multipleChoiceDefaultValues' => 'setMultipleChoiceDefaultValues',
        'penColor' => 'setPenColor',
        'signatureType' => 'setSignatureType',
        'signatureStyle' => 'setSignatureStyle',
        'fontDecoration' => 'setFontDecoration',
        'fontName' => 'setFontName',
        'fontSize' => 'setFontSize',
        'horizontalAlignment' => 'setHorizontalAlignment',
        'signerInputType' => 'setSignerInputType',
        'verticalAlignment' => 'setVerticalAlignment',
        'wordWrap' => 'setWordWrap',
        'formatterType' => 'setFormatterType',
        'formatterCode' => 'setFormatterCode'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'borderSides' => 'getBorderSides',
        'certified' => 'getCertified',
        'fieldType' => 'getFieldType',
        'inputType' => 'getInputType',
        'instructions' => 'getInstructions',
        'name' => 'getName',
        'pageIndex' => 'getPageIndex',
        'position' => 'getPosition',
        'required' => 'getRequired',
        'hidden' => 'getHidden',
        'signer' => 'getSigner',
        'size' => 'getSize',
        'sourceGroup' => 'getSourceGroup',
        'tag' => 'getTag',
        'fixedText' => 'getFixedText',
        'timing' => 'getTiming',
        'options' => 'getOptions',
        'multipleChoiceDefaultValues' => 'getMultipleChoiceDefaultValues',
        'penColor' => 'getPenColor',
        'signatureType' => 'getSignatureType',
        'signatureStyle' => 'getSignatureStyle',
        'fontDecoration' => 'getFontDecoration',
        'fontName' => 'getFontName',
        'fontSize' => 'getFontSize',
        'horizontalAlignment' => 'getHorizontalAlignment',
        'signerInputType' => 'getSignerInputType',
        'verticalAlignment' => 'getVerticalAlignment',
        'wordWrap' => 'getWordWrap',
        'formatterType' => 'getFormatterType',
        'formatterCode' => 'getFormatterCode'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const FIELD_TYPE_TYPED = 'Typed';
    const FIELD_TYPE_SIGNATURE = 'Signature';
    const INPUT_TYPE_SIGNER = 'Signer';
    const INPUT_TYPE_FIXED = 'Fixed';
    const INPUT_TYPE_SIGNATORY = 'Signatory';
    const TIMING_START = 'On_Document_Start';
    const TIMING_COMPLETE = 'On_Document_Complete';
    const PEN_COLOR_BLACK = 'Black';
    const PEN_COLOR_BLUE = 'Blue';
    const SIGNATURE_TYPE_SIGNATURE = 'Signature';
    const SIGNATURE_TYPE_INITIALS = 'Initials';
    const SIGNATURE_STYLE_SELECTABLE = 'Selectable';
    const SIGNATURE_STYLE_DRAWN = 'Drawn';
    const SIGNATURE_STYLE_TYPED = 'Typed';
    const SIGNATURE_STYLE_CLASSIC = 'Classic';
    const FONT_NAME_ARIAL = 'Arial';
    const FONT_NAME_BRADLEY_HAND_ITC = 'Bradley_Hand_ITC';
    const FONT_NAME_BRUSH_SCRIPT_BT = 'Brush_Script_BT';
    const FONT_NAME_COURIER_NEW = 'Courier_New';
    const FONT_NAME_TIMES_NEW_ROMAN = 'Times_New_Roman';
    const FONT_NAME_MY_HANDWRITING = 'My_Handwriting';
    const FONT_NAME_OTTO = 'Otto';
    const HORIZONTAL_ALIGNMENT_LEFT = 'Left';
    const HORIZONTAL_ALIGNMENT_CENTER = 'Center';
    const HORIZONTAL_ALIGNMENT_RIGHT = 'Right';
    const SIGNER_INPUT_TYPE_FREE_TEXT = 'Free_Text';
    const SIGNER_INPUT_TYPE_PREFILL = 'Prefill';
    const SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_TEXT = 'Multiple_Choice_Text';
    const SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_GRAPHIC = 'Multiple_Choice_Graphic';
    const SIGNER_INPUT_TYPE_TIMESTAMP = 'Timestamp';
    const SIGNER_INPUT_TYPE_CUSTOM_VALIDATION = 'Custom_Validation';
    const SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_RADIO = 'Multiple_Choice_Radio';
    const SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_CHECKBOX = 'Multiple_Choice_Checkbox';
    const SIGNER_INPUT_TYPE_UNDEFINED = 'Undefined';
    const VERTICAL_ALIGNMENT_TOP = 'Top';
    const VERTICAL_ALIGNMENT_MIDDLE = 'Middle';
    const VERTICAL_ALIGNMENT_BOTTOM = 'Bottom';
    const FORMATTER_TYPE_ALPHANUMERIC = 'ALPHANUMERIC';
    const FORMATTER_TYPE_CREDITCARD = 'CREDITCARD';
    const FORMATTER_TYPE_SSN = 'SSN';
    const FORMATTER_TYPE_CUSTOM = 'CUSTOM';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFieldTypeAllowableValues()
    {
        return [
            self::FIELD_TYPE_TYPED,
            self::FIELD_TYPE_SIGNATURE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInputTypeAllowableValues()
    {
        return [
            self::INPUT_TYPE_SIGNER,
            self::INPUT_TYPE_FIXED,
            self::INPUT_TYPE_SIGNATORY,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTimingAllowableValues()
    {
        return [
            self::TIMING_START,
            self::TIMING_COMPLETE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPenColorAllowableValues()
    {
        return [
            self::PEN_COLOR_BLACK,
            self::PEN_COLOR_BLUE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSignatureTypeAllowableValues()
    {
        return [
            self::SIGNATURE_TYPE_SIGNATURE,
            self::SIGNATURE_TYPE_INITIALS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSignatureStyleAllowableValues()
    {
        return [
            self::SIGNATURE_STYLE_SELECTABLE,
            self::SIGNATURE_STYLE_DRAWN,
            self::SIGNATURE_STYLE_TYPED,
            self::SIGNATURE_STYLE_CLASSIC,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFontNameAllowableValues()
    {
        return [
            self::FONT_NAME_ARIAL,
            self::FONT_NAME_BRADLEY_HAND_ITC,
            self::FONT_NAME_BRUSH_SCRIPT_BT,
            self::FONT_NAME_COURIER_NEW,
            self::FONT_NAME_TIMES_NEW_ROMAN,
            self::FONT_NAME_MY_HANDWRITING,
            self::FONT_NAME_OTTO,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHorizontalAlignmentAllowableValues()
    {
        return [
            self::HORIZONTAL_ALIGNMENT_LEFT,
            self::HORIZONTAL_ALIGNMENT_CENTER,
            self::HORIZONTAL_ALIGNMENT_RIGHT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSignerInputTypeAllowableValues()
    {
        return [
            self::SIGNER_INPUT_TYPE_FREE_TEXT,
            self::SIGNER_INPUT_TYPE_PREFILL,
            self::SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_TEXT,
            self::SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_GRAPHIC,
            self::SIGNER_INPUT_TYPE_TIMESTAMP,
            self::SIGNER_INPUT_TYPE_CUSTOM_VALIDATION,
            self::SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_RADIO,
            self::SIGNER_INPUT_TYPE_MULTIPLE_CHOICE_CHECKBOX,
            self::SIGNER_INPUT_TYPE_UNDEFINED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getVerticalAlignmentAllowableValues()
    {
        return [
            self::VERTICAL_ALIGNMENT_TOP,
            self::VERTICAL_ALIGNMENT_MIDDLE,
            self::VERTICAL_ALIGNMENT_BOTTOM,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFormatterTypeAllowableValues()
    {
        return [
            self::FORMATTER_TYPE_ALPHANUMERIC,
            self::FORMATTER_TYPE_CREDITCARD,
            self::FORMATTER_TYPE_SSN,
            self::FORMATTER_TYPE_CUSTOM,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['borderSides'] = isset($data['borderSides']) ? $data['borderSides'] : null;
        $this->container['certified'] = isset($data['certified']) ? $data['certified'] : null;
        $this->container['fieldType'] = isset($data['fieldType']) ? $data['fieldType'] : null;
        $this->container['inputType'] = isset($data['inputType']) ? $data['inputType'] : null;
        $this->container['instructions'] = isset($data['instructions']) ? $data['instructions'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['pageIndex'] = isset($data['pageIndex']) ? $data['pageIndex'] : null;
        $this->container['position'] = isset($data['position']) ? $data['position'] : null;
        $this->container['required'] = isset($data['required']) ? $data['required'] : null;
        $this->container['hidden'] = isset($data['hidden']) ? $data['hidden'] : null;
        $this->container['signer'] = isset($data['signer']) ? $data['signer'] : null;
        $this->container['size'] = isset($data['size']) ? $data['size'] : null;
        $this->container['sourceGroup'] = isset($data['sourceGroup']) ? $data['sourceGroup'] : null;
        $this->container['tag'] = isset($data['tag']) ? $data['tag'] : null;
        $this->container['fixedText'] = isset($data['fixedText']) ? $data['fixedText'] : null;
        $this->container['timing'] = isset($data['timing']) ? $data['timing'] : null;
        $this->container['options'] = isset($data['options']) ? $data['options'] : null;
        $this->container['multipleChoiceDefaultValues'] = isset($data['multipleChoiceDefaultValues']) ? $data['multipleChoiceDefaultValues'] : null;
        $this->container['penColor'] = isset($data['penColor']) ? $data['penColor'] : null;
        $this->container['signatureType'] = isset($data['signatureType']) ? $data['signatureType'] : null;
        $this->container['signatureStyle'] = isset($data['signatureStyle']) ? $data['signatureStyle'] : null;
        $this->container['fontDecoration'] = isset($data['fontDecoration']) ? $data['fontDecoration'] : null;
        $this->container['fontName'] = isset($data['fontName']) ? $data['fontName'] : null;
        $this->container['fontSize'] = isset($data['fontSize']) ? $data['fontSize'] : null;
        $this->container['horizontalAlignment'] = isset($data['horizontalAlignment']) ? $data['horizontalAlignment'] : null;
        $this->container['signerInputType'] = isset($data['signerInputType']) ? $data['signerInputType'] : null;
        $this->container['verticalAlignment'] = isset($data['verticalAlignment']) ? $data['verticalAlignment'] : null;
        $this->container['wordWrap'] = isset($data['wordWrap']) ? $data['wordWrap'] : null;
        $this->container['formatterType'] = isset($data['formatterType']) ? $data['formatterType'] : null;
        $this->container['formatterCode'] = isset($data['formatterCode']) ? $data['formatterCode'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getFieldTypeAllowableValues();
        if (!is_null($this->container['fieldType']) && !in_array($this->container['fieldType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'fieldType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getInputTypeAllowableValues();
        if (!is_null($this->container['inputType']) && !in_array($this->container['inputType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'inputType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTimingAllowableValues();
        if (!is_null($this->container['timing']) && !in_array($this->container['timing'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'timing', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPenColorAllowableValues();
        if (!is_null($this->container['penColor']) && !in_array($this->container['penColor'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'penColor', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSignatureTypeAllowableValues();
        if (!is_null($this->container['signatureType']) && !in_array($this->container['signatureType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'signatureType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSignatureStyleAllowableValues();
        if (!is_null($this->container['signatureStyle']) && !in_array($this->container['signatureStyle'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'signatureStyle', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getFontNameAllowableValues();
        if (!is_null($this->container['fontName']) && !in_array($this->container['fontName'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'fontName', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getHorizontalAlignmentAllowableValues();
        if (!is_null($this->container['horizontalAlignment']) && !in_array($this->container['horizontalAlignment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'horizontalAlignment', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSignerInputTypeAllowableValues();
        if (!is_null($this->container['signerInputType']) && !in_array($this->container['signerInputType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'signerInputType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getVerticalAlignmentAllowableValues();
        if (!is_null($this->container['verticalAlignment']) && !in_array($this->container['verticalAlignment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'verticalAlignment', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getFormatterTypeAllowableValues();
        if (!is_null($this->container['formatterType']) && !in_array($this->container['formatterType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'formatterType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets borderSides
     *
     * @return \Nmusco\AssureSign\v3\Model\FieldBorderSides|null
     */
    public function getBorderSides()
    {
        return $this->container['borderSides'];
    }

    /**
     * Sets borderSides
     *
     * @param \Nmusco\AssureSign\v3\Model\FieldBorderSides|null $borderSides borderSides
     *
     * @return $this
     */
    public function setBorderSides($borderSides)
    {
        $this->container['borderSides'] = $borderSides;

        return $this;
    }

    /**
     * Gets certified
     *
     * @return bool|null
     */
    public function getCertified()
    {
        return $this->container['certified'];
    }

    /**
     * Sets certified
     *
     * @param bool|null $certified Specifies whether or not printed metadata uniquely identifying the field should be rendered around it to visually distinguish it from other data on the containing page.
     *
     * @return $this
     */
    public function setCertified($certified)
    {
        $this->container['certified'] = $certified;

        return $this;
    }

    /**
     * Gets fieldType
     *
     * @return string|null
     */
    public function getFieldType()
    {
        return $this->container['fieldType'];
    }

    /**
     * Sets fieldType
     *
     * @param string|null $fieldType Specifies the type of input required for the field: signature/initials or text.
     *
     * @return $this
     */
    public function setFieldType($fieldType)
    {
        $allowedValues = $this->getFieldTypeAllowableValues();
        if (!is_null($fieldType) && !in_array($fieldType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'fieldType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fieldType'] = $fieldType;

        return $this;
    }

    /**
     * Gets inputType
     *
     * @return string|null
     */
    public function getInputType()
    {
        return $this->container['inputType'];
    }

    /**
     * Sets inputType
     *
     * @param string|null $inputType Specifies the source of the input for the field.  Possible values include &apos;Signer&apos; and &apos;Fixed&apos;.
     *
     * @return $this
     */
    public function setInputType($inputType)
    {
        $allowedValues = $this->getInputTypeAllowableValues();
        if (!is_null($inputType) && !in_array($inputType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'inputType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['inputType'] = $inputType;

        return $this;
    }

    /**
     * Gets instructions
     *
     * @return string|null
     */
    public function getInstructions()
    {
        return $this->container['instructions'];
    }

    /**
     * Sets instructions
     *
     * @param string|null $instructions Specifies the instructions that will be presented to the signer when they are prompted to provide input for the field.
     *
     * @return $this
     */
    public function setInstructions($instructions)
    {
        $this->container['instructions'] = $instructions;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name Specifies the name of the field.
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets pageIndex
     *
     * @return int|null
     */
    public function getPageIndex()
    {
        return $this->container['pageIndex'];
    }

    /**
     * Sets pageIndex
     *
     * @param int|null $pageIndex Specifies the 0-based index of the containing page.
     *
     * @return $this
     */
    public function setPageIndex($pageIndex)
    {
        $this->container['pageIndex'] = $pageIndex;

        return $this;
    }

    /**
     * Gets position
     *
     * @return \Nmusco\AssureSign\v3\Model\Coordinate|null
     */
    public function getPosition()
    {
        return $this->container['position'];
    }

    /**
     * Sets position
     *
     * @param \Nmusco\AssureSign\v3\Model\Coordinate|null $position position
     *
     * @return $this
     */
    public function setPosition($position)
    {
        $this->container['position'] = $position;

        return $this;
    }

    /**
     * Gets required
     *
     * @return bool|null
     */
    public function getRequired()
    {
        return $this->container['required'];
    }

    /**
     * Sets required
     *
     * @param bool|null $required Specifies whether or not signer input is required for the field.
     *
     * @return $this
     */
    public function setRequired($required)
    {
        $this->container['required'] = $required;

        return $this;
    }

    /**
     * Gets hidden
     *
     * @return bool|null
     */
    public function getHidden()
    {
        return $this->container['hidden'];
    }

    /**
     * Sets hidden
     *
     * @param bool|null $hidden Specifies whether or not the field is hidden.
     *
     * @return $this
     */
    public function setHidden($hidden)
    {
        $this->container['hidden'] = $hidden;

        return $this;
    }

    /**
     * Gets signer
     *
     * @return string|null
     */
    public function getSigner()
    {
        return $this->container['signer'];
    }

    /**
     * Sets signer
     *
     * @param string|null $signer Specifies the label identifying the intended signer for fields that require signer input (signature or text).
     *
     * @return $this
     */
    public function setSigner($signer)
    {
        $this->container['signer'] = $signer;

        return $this;
    }

    /**
     * Gets size
     *
     * @return \Nmusco\AssureSign\v3\Model\FieldSize|null
     */
    public function getSize()
    {
        return $this->container['size'];
    }

    /**
     * Sets size
     *
     * @param \Nmusco\AssureSign\v3\Model\FieldSize|null $size size
     *
     * @return $this
     */
    public function setSize($size)
    {
        $this->container['size'] = $size;

        return $this;
    }

    /**
     * Gets sourceGroup
     *
     * @return string|null
     */
    public function getSourceGroup()
    {
        return $this->container['sourceGroup'];
    }

    /**
     * Sets sourceGroup
     *
     * @param string|null $sourceGroup Optionally specifies a common identifier for a group of fields in an envelope that should share a value.
     *
     * @return $this
     */
    public function setSourceGroup($sourceGroup)
    {
        $this->container['sourceGroup'] = $sourceGroup;

        return $this;
    }

    /**
     * Gets tag
     *
     * @return string|null
     */
    public function getTag()
    {
        return $this->container['tag'];
    }

    /**
     * Sets tag
     *
     * @param string|null $tag A generic holder of any information you would like to provide
     *
     * @return $this
     */
    public function setTag($tag)
    {
        $this->container['tag'] = $tag;

        return $this;
    }

    /**
     * Gets fixedText
     *
     * @return string|null
     */
    public function getFixedText()
    {
        return $this->container['fixedText'];
    }

    /**
     * Sets fixedText
     *
     * @param string|null $fixedText Specifies the text contents for the field for fields with a &apos;FieldType&apos; of &apos;Typed&apos; and an &apos;InputType&apos; of &apos;Fixed&apos;.  Note: content may include merge fields.
     *
     * @return $this
     */
    public function setFixedText($fixedText)
    {
        $this->container['fixedText'] = $fixedText;

        return $this;
    }

    /**
     * Gets timing
     *
     * @return string|null
     */
    public function getTiming()
    {
        return $this->container['timing'];
    }

    /**
     * Sets timing
     *
     * @param string|null $timing Specifies the timing for when the contents of the field will be rendered to the containing document for fields with a &apos;FieldType&apos; of &apos;Typed&apos; and an &apos;InputType&apos; of &apos;Fixed&apos;.
     *
     * @return $this
     */
    public function setTiming($timing)
    {
        $allowedValues = $this->getTimingAllowableValues();
        if (!is_null($timing) && !in_array($timing, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'timing', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['timing'] = $timing;

        return $this;
    }

    /**
     * Gets options
     *
     * @return \Nmusco\AssureSign\v3\Model\FieldOption[]|null
     */
    public function getOptions()
    {
        return $this->container['options'];
    }

    /**
     * Sets options
     *
     * @param \Nmusco\AssureSign\v3\Model\FieldOption[]|null $options Provides the list of options to present to the signer for fields with a &apos;FieldType&apos; of &apos;Typed&apos; and one of the &apos;Multiple Choice&apos; signatory input types.
     *
     * @return $this
     */
    public function setOptions($options)
    {
        $this->container['options'] = $options;

        return $this;
    }

    /**
     * Gets multipleChoiceDefaultValues
     *
     * @return string[]|null
     */
    public function getMultipleChoiceDefaultValues()
    {
        return $this->container['multipleChoiceDefaultValues'];
    }

    /**
     * Sets multipleChoiceDefaultValues
     *
     * @param string[]|null $multipleChoiceDefaultValues Specify list of values that will be automatically selected upon signing.
     *
     * @return $this
     */
    public function setMultipleChoiceDefaultValues($multipleChoiceDefaultValues)
    {
        $this->container['multipleChoiceDefaultValues'] = $multipleChoiceDefaultValues;

        return $this;
    }

    /**
     * Gets penColor
     *
     * @return string|null
     */
    public function getPenColor()
    {
        return $this->container['penColor'];
    }

    /**
     * Sets penColor
     *
     * @param string|null $penColor Specifies the color of &apos;ink&apos; used to render the signature for fields with a &apos;FieldType&apos; of &apos;Signature&apos;.
     *
     * @return $this
     */
    public function setPenColor($penColor)
    {
        $allowedValues = $this->getPenColorAllowableValues();
        if (!is_null($penColor) && !in_array($penColor, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'penColor', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['penColor'] = $penColor;

        return $this;
    }

    /**
     * Gets signatureType
     *
     * @return string|null
     */
    public function getSignatureType()
    {
        return $this->container['signatureType'];
    }

    /**
     * Sets signatureType
     *
     * @param string|null $signatureType Specifies the type of signature (initials or signature) the signer will be prompted to provide for fields with a &apos;FieldType&apos; of &apos;Signature&apos;.
     *
     * @return $this
     */
    public function setSignatureType($signatureType)
    {
        $allowedValues = $this->getSignatureTypeAllowableValues();
        if (!is_null($signatureType) && !in_array($signatureType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'signatureType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['signatureType'] = $signatureType;

        return $this;
    }

    /**
     * Gets signatureStyle
     *
     * @return string|null
     */
    public function getSignatureStyle()
    {
        return $this->container['signatureStyle'];
    }

    /**
     * Sets signatureStyle
     *
     * @param string|null $signatureStyle Specifies the style of signature the signer will adopt for fields with a &apos;FieldType&apos; of &apos;Signature&apos;.
     *
     * @return $this
     */
    public function setSignatureStyle($signatureStyle)
    {
        $allowedValues = $this->getSignatureStyleAllowableValues();
        if (!is_null($signatureStyle) && !in_array($signatureStyle, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'signatureStyle', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['signatureStyle'] = $signatureStyle;

        return $this;
    }

    /**
     * Gets fontDecoration
     *
     * @return \Nmusco\AssureSign\v3\Model\FieldFontDecoration|null
     */
    public function getFontDecoration()
    {
        return $this->container['fontDecoration'];
    }

    /**
     * Sets fontDecoration
     *
     * @param \Nmusco\AssureSign\v3\Model\FieldFontDecoration|null $fontDecoration fontDecoration
     *
     * @return $this
     */
    public function setFontDecoration($fontDecoration)
    {
        $this->container['fontDecoration'] = $fontDecoration;

        return $this;
    }

    /**
     * Gets fontName
     *
     * @return string|null
     */
    public function getFontName()
    {
        return $this->container['fontName'];
    }

    /**
     * Sets fontName
     *
     * @param string|null $fontName Specifies the name of the supported font that should be used to render the contents of the field for fields with a &apos;FieldType&apos; of &apos;Typed&apos;.
     *
     * @return $this
     */
    public function setFontName($fontName)
    {
        $allowedValues = $this->getFontNameAllowableValues();
        if (!is_null($fontName) && !in_array($fontName, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'fontName', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fontName'] = $fontName;

        return $this;
    }

    /**
     * Gets fontSize
     *
     * @return int|null
     */
    public function getFontSize()
    {
        return $this->container['fontSize'];
    }

    /**
     * Sets fontSize
     *
     * @param int|null $fontSize Specifies the size of the font that should be used to render the contents of the field for fields with a &apos;FieldType&apos; of &apos;Typed&apos;.  Possible values include: 6, 8, 10, 12, 14
     *
     * @return $this
     */
    public function setFontSize($fontSize)
    {
        $this->container['fontSize'] = $fontSize;

        return $this;
    }

    /**
     * Gets horizontalAlignment
     *
     * @return string|null
     */
    public function getHorizontalAlignment()
    {
        return $this->container['horizontalAlignment'];
    }

    /**
     * Sets horizontalAlignment
     *
     * @param string|null $horizontalAlignment Specifies the horizontal alignment of the field contents for fields with a &apos;FieldType&apos; of &apos;Typed&apos;.
     *
     * @return $this
     */
    public function setHorizontalAlignment($horizontalAlignment)
    {
        $allowedValues = $this->getHorizontalAlignmentAllowableValues();
        if (!is_null($horizontalAlignment) && !in_array($horizontalAlignment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'horizontalAlignment', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['horizontalAlignment'] = $horizontalAlignment;

        return $this;
    }

    /**
     * Gets signerInputType
     *
     * @return string|null
     */
    public function getSignerInputType()
    {
        return $this->container['signerInputType'];
    }

    /**
     * Sets signerInputType
     *
     * @param string|null $signerInputType Specifies the type of input required from the signer for fields with a &apos;FieldType&apos; of &apos;Typed&apos;.
     *
     * @return $this
     */
    public function setSignerInputType($signerInputType)
    {
        $allowedValues = $this->getSignerInputTypeAllowableValues();
        if (!is_null($signerInputType) && !in_array($signerInputType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'signerInputType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['signerInputType'] = $signerInputType;

        return $this;
    }

    /**
     * Gets verticalAlignment
     *
     * @return string|null
     */
    public function getVerticalAlignment()
    {
        return $this->container['verticalAlignment'];
    }

    /**
     * Sets verticalAlignment
     *
     * @param string|null $verticalAlignment Specifies the vertical alignment of the field contents for fields with a &apos;FieldType&apos; of &apos;Typed&apos;.
     *
     * @return $this
     */
    public function setVerticalAlignment($verticalAlignment)
    {
        $allowedValues = $this->getVerticalAlignmentAllowableValues();
        if (!is_null($verticalAlignment) && !in_array($verticalAlignment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'verticalAlignment', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['verticalAlignment'] = $verticalAlignment;

        return $this;
    }

    /**
     * Gets wordWrap
     *
     * @return bool|null
     */
    public function getWordWrap()
    {
        return $this->container['wordWrap'];
    }

    /**
     * Sets wordWrap
     *
     * @param bool|null $wordWrap Specifies whether or not the contents of the field should be automatically wrapped to a new line for fields with a &apos;FieldType&apos; of &apos;Typed&apos;.
     *
     * @return $this
     */
    public function setWordWrap($wordWrap)
    {
        $this->container['wordWrap'] = $wordWrap;

        return $this;
    }

    /**
     * Gets formatterType
     *
     * @return string|null
     */
    public function getFormatterType()
    {
        return $this->container['formatterType'];
    }

    /**
     * Sets formatterType
     *
     * @param string|null $formatterType Specifies the text mask to apply for fields with a &apos;FieldType&apos; of &apos;Typed&apos;.
     *
     * @return $this
     */
    public function setFormatterType($formatterType)
    {
        $allowedValues = $this->getFormatterTypeAllowableValues();
        if (!is_null($formatterType) && !in_array($formatterType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'formatterType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['formatterType'] = $formatterType;

        return $this;
    }

    /**
     * Gets formatterCode
     *
     * @return string|null
     */
    public function getFormatterCode()
    {
        return $this->container['formatterCode'];
    }

    /**
     * Sets formatterCode
     *
     * @param string|null $formatterCode Specifies the custom text mask to apply for fields with a &apos;FieldType&apos; of &apos;Typed&apos; and a &apos;FormatterType&apos; of &apos;Fixed&apos;.
     *
     * @return $this
     */
    public function setFormatterCode($formatterCode)
    {
        $this->container['formatterCode'] = $formatterCode;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


